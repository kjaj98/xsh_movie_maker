import numpy as np 

BOHR_PER_ANG = 1.0 / 0.52917721092   # Å -> Bohr

def read_xyz_trajectory(filename):
    frames = []
    with open(filename, "r") as f:
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            if not line:
                break

            natoms = int(line)
            comment = f.readline().rstrip("\n")
            # e.g. " i =        0, time =        0.000, E = ..."
            time_str = comment.split(",")[1]
            time_fs = float(time_str.split("=")[1].strip())

            atoms = []
            coords = []
            for _ in range(natoms):
                parts = f.readline().split()
                atoms.append(parts[0])
                coords.append([float(x) for x in parts[1:4]])

            frames.append({
                "time_fs": time_fs,
                "atoms": atoms,
                "coords": np.array(coords),
            })
    return frames

def read_coeffs(filename):
    frames = []
    with open(filename, "r") as f:
        while True:
            header = f.readline()
            if not header:
                break
            header = header.strip()
            if not header.startswith("Psi;"):
                continue

            time_line = f.readline().strip()
            time_parts = time_line.split(",")
            time_fs = float(time_parts[1].split("=")[1].strip().split()[0])

            coeffs = []
            while True:
                pos = f.tell()
                line = f.readline()
                if (not line) or line.strip().startswith("Psi;"):
                    if line and line.strip().startswith("Psi;"):
                        f.seek(pos)
                    break
                parts = line.strip().split()
                re = float(parts[2])
                im = float(parts[3])
                coeffs.append(re + 1j * im)

            frames.append({
                "time_fs": time_fs,
                "coefficients": np.array(coeffs, dtype=complex),
            })
    return frames

def read_aom_fragment(filename, natoms_fragment):
    """
    Read AOM coefficients for ONE fragment (one monomer) from 'filename'.

    Assumptions:
      - The first natoms_fragment lines that have >= coeff_col+1 fields
        correspond to the fragment atoms, in the same order as the monomer's XYZ.
      - The coefficient we want is in column 'coeff_col'.
    """
    aom = np.zeros(natoms_fragment, dtype=float)
    with open(filename, "r") as f:
        atom_idx = 0
        for line in f:
            if atom_idx >= natoms_fragment:
                break
            parts = line.strip().split()
            if len(parts) <= 4:
                continue
            coeff = float(parts[4])
            aom[atom_idx] = coeff
            atom_idx += 1

    if atom_idx != natoms_fragment:
        raise ValueError(
            f"Expected {natoms_fragment} AOM coefficients in {filename}, "
            f"but only read {atom_idx}"
        )

    return aom

def write_cube(filename, grid_x, grid_y, grid_z, data, atoms, coords,
               units="angstrom"):
    nx, ny, nz = data.shape

    # scale factor: internal coords are in Å
    if units.lower().startswith("bohr"):
        fac = BOHR_PER_ANG    # convert Å -> Bohr
    else:
        fac = 1.0             # keep Å as-is

    origin = fac * np.array([grid_x[0], grid_y[0], grid_z[0]])

    dx = fac * (grid_x[1] - grid_x[0])
    dy = fac * (grid_y[1] - grid_y[0])
    dz = fac * (grid_z[1] - grid_z[0])

    with open(filename, "w") as f:
        f.write("CUBE FILE GENERATED BY xsh_movie_maker\n")
        f.write("OUTER LOOP: X, MIDDLE LOOP: Y, INNER LOOP: Z\n")
        # origin line
        f.write(f"{len(atoms):5d}{origin[0]:12.6f}{origin[1]:12.6f}{origin[2]:12.6f}\n")
        # axis vectors
        f.write(f"{nx:5d}{dx:12.6f}{0.0:12.6f}{0.0:12.6f}\n")
        f.write(f"{ny:5d}{0.0:12.6f}{dy:12.6f}{0.0:12.6f}\n")
        f.write(f"{nz:5d}{0.0:12.6f}{0.0:12.6f}{dz:12.6f}\n")

        Zmap = {"H": 1, "C": 6, "N": 7, "O": 8, "S": 16}
        for sym, (x, y, z) in zip(atoms, coords):
            Z = Zmap.get(sym, 0)
            x_b, y_b, z_b = fac * x, fac * y, fac * z
            f.write(f"{Z:5d}{float(Z):12.6f}{x_b:12.6f}{y_b:12.6f}{z_b:12.6f}\n")

        flat = data.reshape(-1)
        for i, val in enumerate(flat):
            f.write(f"{val:13.5e}")
            if (i + 1) % 6 == 0:
                f.write("\n")
        if len(flat) % 6 != 0:
            f.write("\n")

def write_single_frame_xyz(filename, atoms, coords, time_fs=None):
    """
    Write a single XYZ frame to `filename` with an optional time in the comment.
    """
    natoms = len(atoms)
    if coords.shape[0] != natoms:
        raise ValueError("atoms and coords length mismatch in write_single_frame_xyz")

    if time_fs is None:
        comment = "single frame"
    else:
        comment = f"time = {time_fs:.3f} fs"

    with open(filename, "w") as f:
        f.write(f"{natoms}\n")
        f.write(comment + "\n")
        for sym, (x, y, z) in zip(atoms, coords):
            f.write(f"{sym:2s} {x:16.8f} {y:16.8f} {z:16.8f}\n")
